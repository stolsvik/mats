package com.stolsvik.mats.jupiter;

import javax.inject.Inject;

import org.junit.jupiter.api.extension.AfterEachCallback;
import org.junit.jupiter.api.extension.BeforeEachCallback;
import org.junit.jupiter.api.extension.ExtensionContext;

import com.stolsvik.mats.MatsEndpoint.ProcessSingleLambda;
import com.stolsvik.mats.MatsFactory;
import com.stolsvik.mats.jupiter.spring.ExtensionMatsAutowireTestExecutionListener;
import com.stolsvik.mats.test.abstractunit.AbstractMatsTestEndpoint;

/**
 * Extension to create a single staged endpoint whose reply/processor can be changed throughout its life, i.e. per test
 * (e.g. answer "Sorry, no can do." for the first test, and then "Yes, we can!" for the next test). The Extension can be
 * instantiated {@link #single(String, Class, Class, ProcessSingleLambda) with} or {@link #single(String, Class, Class)
 * without} a predefined processor. Useful for mocking endpoints in tests where you need predictable replies, and may
 * also be used to verify that an endpoint was <em>not</em> invoked.
 * <p>
 * The endpoint processor can be changed on demand using {@link #setProcessLambda(ProcessSingleLambda)}
 * <p>
 * Must be annotated with {@link org.junit.jupiter.api.extension.RegisterExtension @RegisterExtension}.
 * <p>
 * Retrieve the endpoint's received(incoming) message/messages by calling on of the following methods:
 * <ul>
 *     <li>{@link Extension_MatsEndpoint#waitForRequest()} - Wait for a message(singular) using the default timeout</li>
 *     <li>{@link Extension_MatsEndpoint#waitForRequest(long)} - Wait for a message(singular) with user specified timeout</li>
 *     <li>{@link Extension_MatsEndpoint#waitForRequests(int)} - Wait for X messages using the default timeout</li>
 *     <li>{@link Extension_MatsEndpoint#waitForRequests(int, long)} - Wait for X messages with user specified timeout</li>
 * </ul>
 * Given a case where one does not expect the endpoint to be invoked (no messages received) one can utilize
 * {@link Extension_MatsEndpoint#verifyNotInvoked()} to ensure that the endpoint was not in fact invoked during the test.
 * <p>
 * If no process lambda is specified for the endpoint it will act as a terminator, thus it does not generate a reply.
 * <p>
 * <pre>
 *     &#64;RegisterExtension
 *     public Extension_MatsEndpoint&lt;String, String&gt; _world = Extension_MatsEndpoint.single(endpointFactory, "World",
 *     String.class, String.class, (context, in) -> in + "World");
 * </pre>
 * Should one want to utilize this test endpoint approach in a test which brings up a Spring context which contains a
 * {@link MatsFactory} one can utilize the {@link ExtensionMatsAutowireTestExecutionListener}
 * which will inject/autowire this class automatically by providing the {@link MatsFactory} located in said Spring
 * context.
 * <pre>
 *     &#64;TestExecutionListeners(value = {ExtensionMatsAutowireTestExecutionListener.class},
 *     mergeMode = MergeMode.MERGE_WITH_DEFAULTS)
 * </pre>
 *
 * @param <R>
 *         The reply class of the message generated by this endpoint. (Reply Class)
 * @param <I>
 *         The incoming message class for this endpoint. (Request Class)
 * @author Kevin Mc Tiernan, 22-10-2020, kmctiernan@gmail.com
 */
public class Extension_MatsEndpoint<R, I> extends AbstractMatsTestEndpoint<R, I> implements BeforeEachCallback,
        AfterEachCallback {

    /**
     * Private constructor, utilize {@link #single(String, Class, Class)} or {@link #single(String, Class, Class,
     * ProcessSingleLambda)} to create an instance of this object.
     */
    private Extension_MatsEndpoint(String endpointId, Class<R> replyMsgClass, Class<I> incomingMsgClass) {
        super(endpointId, replyMsgClass, incomingMsgClass);
    }

    /**
     * Sets the internal {@link MatsFactory} to be utilized for the creation of this endpoint.
     * <p>
     * If not utilized explicitly can also be injected/autowired through the use of the test execution listener {@link
     * ExtensionMatsAutowireTestExecutionListener} should this Extension be utilized in a test where a Spring context is
     * in play.
     *
     * @param matsFactory
     *         to set.
     * @return this instance of the object.
     */
    @Inject
    @Override
    public Extension_MatsEndpoint<R, I> setMatsFactory(MatsFactory matsFactory) {
        _matsFactory = matsFactory;
        return this;
    }

    /**
     * Creates a Jupiter Extension for a single-staged endpoint whose processLambda is <i>not</i> defined at start. Sets
     * it up on Jupiter lifecycle 'beforeEach' and tears it down on 'afterEach'.
     * <p>
     * <b>Do notice that you need to invoke {@link #setProcessLambda(ProcessSingleLambda)} - typically inside the
     * &#64;Test method - before sending messages to it, as there is no default.</b>
     * <p>
     * Notice the overloaded method {@link #single(String, Class, Class, ProcessSingleLambda)}, which instantiates with
     * a "preloaded" processLambda, and whose signature thus closely resembles that of {@link MatsFactory}. Use {@link
     * #setMatsFactory(MatsFactory)} to set endpoint factory for Extension, or let Spring autowire it if you have a
     * custom Spring TestExecutionListener to inject dependencies in Extension.
     *
     * @param endpointId
     *         of the endpoint.
     * @param replyMsgClass
     *         the class of the reply message generated by this endpoint.
     * @param incomingMsgClass
     *         the incoming message class for this endpoint.
     * @return {@link Extension_Mats} without a predefined processLambda.
     */
    public static <R, I> Extension_MatsEndpoint<R, I> single(String endpointId, Class<R> replyMsgClass,
            Class<I> incomingMsgClass) {
        return new Extension_MatsEndpoint<>(endpointId, replyMsgClass, incomingMsgClass);
    }

    /**
     * Creates a Jupiter Extension for a single-staged endpoint whose processLambda is defined from start - but you can
     * still re-define it by {@link #setProcessLambda(ProcessSingleLambda)}.
     * <p>
     * Sets it up on Jupiter lifecycle 'beforeEach' and tears it down on 'afterEach'. If you intend to use it for
     * several tests with different processLambda's for different replies for each test, it may make more sense to start
     * it without a predefined processLambda {@link #single(String, Class, Class)}.
     * <p>
     * Use {@link #setMatsFactory(MatsFactory)} to set endpoint factory for this extension, or let Spring autowire it if
     * your using {@link ExtensionMatsAutowireTestExecutionListener} to inject dependencies in extensions.
     *
     * @param endpointId
     *         of the endpoint.
     * @param replyMsgClass
     *         the class of the reply message generated by this endpoint.
     * @param incomingMsgClass
     *         the incoming message class for this endpoint.
     * @param processLambda
     *         the processLambda for this endpoint, logic which the endpoint will execute given an incoming message.
     * @return {@link Extension_Mats} with a default processLambda.
     */
    public static <R, I> Extension_MatsEndpoint<R, I> single(String endpointId, Class<R> replyMsgClass,
            Class<I> incomingMsgClass, ProcessSingleLambda<R, I> processLambda) {
        Extension_MatsEndpoint<R, I> eMatsEndpoint = new Extension_MatsEndpoint<>(endpointId, replyMsgClass,
                incomingMsgClass);
        eMatsEndpoint.setProcessLambda(processLambda);
        return eMatsEndpoint;
    }

    // ================== Jupiter LifeCycle ===========================================================================

    @Override
    public void beforeEach(ExtensionContext context) {
        super.before();
    }

    @Override
    public void afterEach(ExtensionContext context) {
        super.after();
    }
}
