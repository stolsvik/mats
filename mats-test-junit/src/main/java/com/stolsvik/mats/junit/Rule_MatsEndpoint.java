package com.stolsvik.mats.junit;

import javax.inject.Inject;

import org.junit.ClassRule;
import org.junit.Rule;

import com.stolsvik.mats.MatsEndpoint.ProcessSingleLambda;
import com.stolsvik.mats.MatsFactory;
import com.stolsvik.mats.junit.spring.RuleMatsAutowireTestExecutionListener;
import com.stolsvik.mats.test.abstractunit.AbstractMatsTestEndpoint;

/**
 * Rule to create a single staged endpoint whose reply/processor can be changed throughout its life, i.e. per test (e.g.
 * answer "Sorry, no can do." for the first test, and then "Yes, we can!" for the next test). The rule can be
 * instantiated {@link #single(String, Class, Class, ProcessSingleLambda) with} or {@link #single(String, Class, Class)
 * without} a predefined processor. Useful for mocking endpoints in tests where you need predictable replies, and may
 * also be used to verify that an endpoint was <em>not</em> invoked.
 * <p>
 * The endpoint processor can be changed on demand using {@link #setProcessLambda(ProcessSingleLambda)}
 * <p>
 * Must be annotated with {@link Rule @Rule}. Do not use with {@link ClassRule @ClassRule}
 * <p>
 * Retrieve the endpoint's received(incoming) message/messages by calling on of the following methods:
 * <ul>
 *     <li>{@link Rule_MatsEndpoint#waitForRequest()} - Wait for a message(singular) using the default timeout</li>
 *     <li>{@link Rule_MatsEndpoint#waitForRequest(long)} - Wait for a message(singular) with user specified timeout</li>
 *     <li>{@link Rule_MatsEndpoint#waitForRequests(int)} - Wait for X messages using the default timeout</li>
 *     <li>{@link Rule_MatsEndpoint#waitForRequests(int, long)} - Wait for X messages with user specified timeout</li>
 * </ul>
 * Given a case where one does not expect the endpoint to be invoked (no messages received) one can utilize
 * {@link Rule_MatsEndpoint#verifyNotInvoked()} to ensure that the endpoint was not in fact invoked during the test.
 * <p>
 * If no process lambda is specified for the endpoint it will act as a terminator, thus it does not generate a reply.
 * <p>
 * <pre>
 *     &#64;Rule
 *     public Rule_MatsEndpoint&lt;String, String&gt; _world = Rule_MatsEndpoint.single(endpointFactory, "World",
 *     String.class, String.class, (context, in) -> in + "World");
 * </pre>
 * Should one want to utilize this test endpoint approach in a test which brings up a Spring context which contains a
 * {@link MatsFactory} one can utilize the {@link RuleMatsAutowireTestExecutionListener}
 * which will inject/autowire this class automatically by providing the {@link MatsFactory} located in said Spring
 * context.
 * <pre>
 *     &#64;TestExecutionListeners(value = {RuleMatsAutowireTestExecutionListener.class},
 *     mergeMode = MergeMode.MERGE_WITH_DEFAULTS)
 * </pre>
 *
 * @param <R>
 *         The reply class of the message generated by this endpoint. (Reply Class)
 * @param <I>
 *         The incoming message class for this endpoint. (Request Class)
 * @author Kevin Mc Tiernan, 2020-10-22, kmctiernan@gmail.com
 */
public class Rule_MatsEndpoint<R, I> extends AbstractMatsTestEndpoint<R, I> implements JUnitLifeCycle {

    /**
     * Private constructor, utilize {@link #single(String, Class, Class)} or {@link #single(String, Class, Class,
     * ProcessSingleLambda)} to create an instance of this object.
     */
    private Rule_MatsEndpoint(String endpointId, Class<R> replyMsgClass, Class<I> incomingMsgClass) {
        super(endpointId, replyMsgClass, incomingMsgClass);
    }

    /**
     * Sets the internal {@link MatsFactory} to be utilized for the creation of this endpoint.
     * <p>
     * If not utilized explicitly can also be injected/autowired through the use of the test execution listener {@link
     * RuleMatsAutowireTestExecutionListener} should this Rule be utilized in a test where a Spring context is in play.
     *
     * @param matsFactory
     *         to set.
     * @return this instance of the object.
     */
    @Inject
    @Override
    public Rule_MatsEndpoint<R, I> setMatsFactory(MatsFactory matsFactory) {
        _matsFactory = matsFactory;
        return this;
    }


    /**
     * Creates a JUnit Rule for a single-staged endpoint whose processor is <i>not</i> defined at start. Sets it up on
     * JUnit lifecycle 'before' and tears it down on 'after'.
     * <p>
     * <b>Do notice that you need to invoke {@link #setProcessLambda(ProcessSingleLambda)} - typically inside the
     * &#64;Test method - before sending messages to it, as there is no default. </b>
     * <p>
     * Notice the overloaded method {@link #single(String, Class, Class, ProcessSingleLambda)}, which instantiates with
     * a "preloaded" processor, and whose signature thus closely resembles that of {@link MatsFactory#single(String,
     * Class, Class, ProcessSingleLambda)}.
     * <p>
     * Use {@link #setMatsFactory(MatsFactory)} to set endpoint factory for rule, or let Spring autowire it if your
     * using {@link RuleMatsAutowireTestExecutionListener} to inject dependencies in rules.
     *
     * @param endpointId
     *         of the endpoint.
     * @param replyMsgClass
     *         the class of the reply message generated by this endpoint.
     * @param incomingMsgClass
     *         the incoming message class for this endpoint.
     * @return {@link Rule_MatsEndpoint}
     */
    public static <R, I> Rule_MatsEndpoint<R, I> single(String endpointId, Class<R> replyMsgClass,
            Class<I> incomingMsgClass) {
        return new Rule_MatsEndpoint<>(endpointId, replyMsgClass, incomingMsgClass);
    }

    /**
     * Creates a JUnit Rule for a single-staged endpoint whose processor is defined from start - but you can still
     * re-define it by {@link #setProcessLambda(ProcessSingleLambda)}.
     * <p>
     * Sets it up on JUnit lifecycle 'before' and tears it down on 'after'. If you intend to use it for several tests
     * with different processors for different replies for each test, it may make more sense to start it without a
     * predefined processor {@link #single(String, Class, Class)}.
     * <p>
     * Use {@link #setMatsFactory(MatsFactory)} to set the endpoint factory for this rule, or let Spring autowire it if
     * your using {@link RuleMatsAutowireTestExecutionListener} to inject dependencies in rules.
     *
     * @param endpointId
     *         of the endpoint.
     * @param replyMsgClass
     *         the reply class of the message generated by this endpoint.
     * @param incomingMsgClass
     *         the incoming message class for this endpoint.
     * @param processLambda
     *         the processLambda for this endpoint, logic which the endpoint will execute given an incoming message.
     * @return {@link Rule_MatsEndpoint}
     */
    public static <R, I> Rule_MatsEndpoint<R, I> single(String endpointId, Class<R> replyMsgClass,
            Class<I> incomingMsgClass, ProcessSingleLambda<R, I> processLambda) {
        Rule_MatsEndpoint<R, I> rMatsEndpoint = new Rule_MatsEndpoint<>(endpointId, replyMsgClass, incomingMsgClass);
        rMatsEndpoint.setProcessLambda(processLambda);
        return rMatsEndpoint;
    }

    // ================== Junit LifeCycle =============================================================================

    @Override
    public void before() {
        super.before();
    }

    @Override
    public void after() {
        super.after();
    }
}
